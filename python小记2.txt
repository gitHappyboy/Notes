#！ /usr/bin/python3
然后 chmod +x hello.py
./hello.py即可执行代码
使用id()函数可以查看变量保存数据所在的内存地址

注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用

变量 不再 对之前的数据引用
变量 改为 对新赋值的数据引用

在 Python 中，函数的 实参 / 返回值 都是是靠 引用 来传递来的
不可变类型(都是字面量)
	数字类型
	字符串
	元组
可变类型
	列表
	字典

字典的key只能使用不可变的类型的数据

python中是不允许直接修改全局变量的值，如果使用赋值语句，只会在函数内部定义一个同名的局部变量
使用global关键字声明全局变量，可以在函数内部修改全局变量
全局变量名前应该增加 g_ 或者 gl_ 的前缀

如果函数返回的数据类型是元组，括号可以省略。
temp, wetness = measure()

python利用元组交换数值
a, b = (b, a) = b, a  # 括号省略了

函数的默认参数
	必须保证 带有默认值的缺省参数 在参数列表末尾
	在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！

多值参数
	有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数
	python 中有 两种 多值参数：

	参数名前增加 一个 * 可以接收 元组
	参数名前增加 两个 * 可以接收 字典
	一般在给多值参数命名时，习惯使用以下两个名字

	*args —— 存放 元组 参数，前面有一个 *
	**kwargs —— 存放 字典 参数，前面有两个 *
	args 是 arguments 的缩写，有变量的含义
	kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数

在调用带有多值参数的函数时，如果希望：

将一个 元组变量，直接传递给 args
将一个 字典变量，直接传递给 kwargs
就可以使用 拆包，简化参数的传递，拆包 的方式是：

在 元组变量前，增加 一个 *
在 字典变量前，增加 两个 *
def demo(*args, **kwargs):

    print(args)
    print(kwargs)


# 需要将一个元组变量/字典变量传递给函数对应的参数
gl_nums = (1, 2, 3)
gl_xiaoming = {"name": "小明", "age": 18}

# 会把 num_tuple 和 xiaoming 作为元组传递个 args
# demo(gl_nums, gl_xiaoming)
demo(*gl_nums, **gl_xiaoming)

python中对象无处不在， 变量、数据、 函数 都是对象

在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表
使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法
提示 __方法名__ 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性

| 序号 | 方法名 | 类型 | 作用 |
| :---: | :---: | :---: | --- | 
| 01 | __new__ | 方法 | 创建对象时，会被 自动 调用 |
| 02 | __init__ | 方法 | 对象被初始化时，会被 自动 调用 |
| 03 | __del__ | 方法 | 对象被从内存中销毁前，会被 自动 调用 |
| 04 | __str__ | 方法 | 返回对象的描述信息，print 函数输出使用 |

方法 的定义格式和之前学习过的函数 几乎一样
区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self
对象变量 = 类名()

给对象增加属性  tom.name = "汤姆"  # 但是不推荐这样做，对象应该包含有哪些属性，应该 封装在类的内部

self就是当前对象的引用
在 类的外部，通过 变量名. 访问对象的 属性和方法
在 类封装的方法中，通过 self. 访问对象的 属性和方法

初始化方法__init__:是对象的内置方法
	在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性
	定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性
	self.属性 = 形参  # 带参构造
 __del__:内置方法，对象销毁前会执行
 __str__:对象的文本描述方法，此方法必须返回一个字符串
 del tom :可以销毁一个对象

一个对象的 属性 可以是 另外一个类创建的对象

定义没有初始值的属性

在定义属性时，如果 不知道设置什么初始值，可以设置为 None

None 关键字 表示 什么都没有
表示一个 空对象，没有方法和属性，是一个特殊的常量
可以将 None 赋值给任何一个变量

在 Python 中针对 None 比较时，建议使用 is 判断
is	is 是判断两个标识符是不是引用同一个对象	x is y，类似 id(x) == id(y)
is not	is not 是判断两个标识符是不是引用不同对象	x is not y，类似 id(a) != id(b)

>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a 
False
>>> b == a
True

在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法
	__age,   __secret(self, age)

Python 中，并没有 真正意义 的 私有, 处理方式：在 名称 前面加上 _类名 => _类名__名称
	xiaoFang._Women__age,  xiaoFang._Women__secret(self)，还是可以访问  

继承的语法
	class 类名(父类名):

  	 	pass

扩展父类方法
	在需要的位置使用 super().父类方法 来调用父类方法的执行
	在 Python 中 super 是一个 特殊的类
	super() 就是使用 super 类创建出来的对象
	最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现
在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式：

	父类名.方法(self)  # 但不推荐使用

多继承
	class 子类名(父类名1, 父类名2...)
    		pass

Python 中针对 类 提供了一个 内置属性 __mro__ 可以查看 方法 搜索顺序
MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径
	print(C.__mro__)

Python 3.x 中定义的类都是 新式类， 以object 作为基类

多态 不同的 子类对象 调用相同的 父类方法，产生不同的执行结果

	多态 可以 增加代码的灵活度
	以 继承 和 重写父类方法 为前提

	
每一个对象 都有自己 独立的内存空间，保存各自不同的属性
多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部

Python 中 一切皆对象：

class AAA: 定义的类属于 类对象
obj1 = AAA() 属于 实例对象
在程序运行时，类 同样 会被加载到内存
在 Python 中，类 是一个特殊的对象 —— 类对象
在程序运行时，类对象 在内存中 只有一份，使用 一个类 可以创建出 很多个对象实例
除了封装 实例 的 属性 和 方法外，类对象 还可以拥有自己的 属性 和 方法

类属性
类方法
通过 类名. 的方式可以 访问类的属性 或者 调用类的方法

python中的属性获取存在一个向上查找的机制
因此，要访问类属性有两种方式：

类名. 类属性
对象. 类属性 （不推荐）
注意

如果使用 对象.类属性 = 值 赋值语句，只会 给对象添加一个属性，而不会影响到 类属性的值

类方法
	@classmethod
	def 类方法名(cls):
		pass
		
类方法的 第一个参数 应该是 cls，和 实例方法 的第一个参数是 self 类似
在 类方法 内部可以使用cls直接访问 类属性 或者调用其他的 类方法

静态方法
	在开发时，如果需要在 类 中封装一个方法，这个方法：

	既 不需要 访问 实例属性 或者调用 实例方法
	也 不需要 访问 类属性 或者调用 类方法
	这个时候，可以把这个方法封装成一个 静态方法
语法如下

	@staticmethod
	def 静态方法名():
		pass
		
	通过 类名. 调用 静态方法
	
方法定义套路：
	实例方法 —— 方法内部需要访问 实例属性

	实例方法 内部可以使用 类名. 访问类属性
	类方法 —— 方法内部 只 需要访问 类属性
	静态方法 —— 方法内部，不需要访问 实例属性 和 类属性
提问

	如果方法内部 即需要访问 实例属性，又需要访问 类属性，应该定义成什么方法？

答案

	应该定义 实例方法
	因为，类只有一个，在 实例方法 内部可以使用 类名. 访问类属性
	
单例设计模式
	目的 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例
	每一次执行 类名() 返回的对象，内存地址是相同的
	
使用 类名 () 创建对象时，Python 的解释器 首先 会 调用 __new__ 方法为对象 分配空间
__new__ 是一个 由 object 基类提供的 内置的静态方法，主要作用有两个：

1) 在内存中为对象 分配空间
2) 返回 对象的引用
	Python 的解释器获得对象的 引用 后，将引用作为 第一个参数，传递给 __init__ 方法
	重写 __new__ 方法 的代码非常固定！

	重写 __new__ 方法 一定要 return super().__new__(cls)  # 调用父类的__new__去分配内存
	否则 Python 的解释器 得不到 分配了空间的 对象引用，就不会调用对象的初始化方法
	注意：__new__ 是一个静态方法，在调用时需要 主动传递 cls 参数

单例 —— 让 类 创建的对象，在系统中 只有 唯一的一个实例

	定义一个 类属性，初始值是 None，用于记录 单例对象的引用
	重写 __new__ 方法
	如果 类属性 is None，调用父类方法分配空间，并在类属性中记录结果
	返回 类属性 中记录的 对象引用
	
在每次使用 类名() 创建对象时，Python 的解释器都会自动调用两个方法：

	__new__ 分配空间
	__init__ 对象初始化
在上一小节对 __new__ 方法改造之后，每次都会得到 第一次被创建对象的引用
	但是：初始化方法还会被再次调用
解决思路：在类中再定义一个has_init变量，记录是否被初始化过，在__init__()每次进行判断。

python中的异常

	try:
		# 尝试执行的代码
		pass
	except 错误类型1:
		# 针对错误类型1，对应的代码处理
		pass
	except 错误类型2:
		# 针对错误类型2，对应的代码处理
		pass
	except (错误类型3, 错误类型4):
		# 针对错误类型3 和 4，对应的代码处理
		pass
	except Exception as result:
		# 打印错误信息
		print(result)
	else:
		# 没有异常才会执行的代码
		pass
	finally:
		# 无论是否有异常，都会执行的代码
		print("无论是否有异常，都会执行的代码")
		
比如：
	try:
		num = int(input("请输入整数："))
		result = 8 / num
		print(result)
	except ValueError:
		print("请输入正确的整数")
	except ZeroDivisionError:
		print("除 0 错误")
	except Exception as result:
		print("未知错误 %s" % result)
	else:
		print("正常执行")
	finally:
		print("执行完成，但是不保证正确")

异常的传递：
	异常的传递 —— 当 函数 / 方法 执行 出现异常，会 将异常传递 给 函数 / 方法 的 调用一方
	如果 传递到主程序，仍然 没有异常处理，程序才会被终止
	
主动抛出异常：在开发时，如果满足 特定业务需求时，希望 抛出异常，可以：

	创建 一个 Exception 的 对象
	使用 raise 关键字 抛出 异常对象   # raise Exception("未知错误")

模块
	每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块
	模块中定义的 全局变量 、函数、类 都是提供给外界直接使用的 工具
	import 模块名1
	通过 模块名. 使用 模块提供的工具 —— 全局变量、函数、类
	# 如果模块的名字太长，可以使用 as 指定模块的名称
	import 模块名1 as 模块别名  # 模块别名 应该符合 大驼峰命名法
	
	from ... import ...
	
	如果希望 从某一个模块 中，导入 部分 工具, from 模块名1 import 工具名
		导入之后 不需要 通过 模块名.
		可以直接使用 模块提供的工具 —— 全局变量、函数、类
	import 模块名 是 一次性 把模块中 所有工具全部导入，并且通过 模块名 / 别名 访问
	
	同名函数覆盖原则
	
	# 从 模块 导入 所有工具  （不推荐使用）
	from 模块名1 import *  # 导入所有工具，导入之后不需要通过 模块名/别名	访问
	
Python 的解释器在 导入模块 时，会：

	搜索 当前目录 指定模块名的文件，如果有就直接导入
	如果没有，再搜索 系统目录	
	因此，在开发时，给文件起名，不要和 系统的模块文件 重名
	Python 中每一个模块都有一个内置属性 __file__ 可以 查看模块 的 完整路径
	
	import random
	print(random.__file__)

一个 独立的 Python 文件 就是一个 模块
	在导入文件时，文件中 所有没有任何缩进的代码 都会被执行一遍！
	
	开发人员 通常会在 模块下方 增加一些测试代码
	仅在模块内使用，而被导入到其他文件中不需要执行
	
	__name__ 是 Python 的一个内置属性，记录着一个 字符串
	如果 是被其他文件导入的，__name__ 就是 模块名
	如果 是当前执行的程序 __name__ 是 __main__
	
	# 导入模块
	# 定义全局变量
	# 定义类
	# 定义函数

	# 在代码的最下方
	def main():
		# ...
		pass

	# 根据 __name__ 判断是否执行下方代码
	if __name__ == "__main__":
		main()
	这样，别人导入我们的模块时，就不会执行main()中的代码
	

包(package)
	包 是一个 包含多个模块 的 特殊目录
	目录下有一个 特殊的文件 __init__.py
	包名的 命名方式 和变量名一致，小写字母 + _
	
	好处：使用 import 包名 可以一次性导入 包 中 所有的模块
	
	注意：要在外界使用 包 中的模块，需要在 __init__.py 中指定 对外界提供的模块列表
		# 从 当前目录 导入 模块列表
		from . import send_message
		from . import receive_message
		
发布模块
	制作发布压缩包
	
		创建 setup.py
		构建模块：$ python3 setup.py build
		生成发布压缩包： python3 setup.py sdist
	
	安装模块
		$ tar -zxvf hm_message-1.0.tar.gz 

		$ sudo python3 setup.py install
		
	卸载模块
	
		直接从安装目录下，把安装模块的 目录 删除就可以

		$ cd /usr/local/lib/python3.5/dist-packages/
		$ sudo rm -r hm_message*
		
	pip 安装第三方模块
		$ sudo pip3 install pygame
		$ sudo pip3 uninstall pygame
	
	
文件的基本操作
	基本套路
		>打开文件
		>读、写文件
		>关闭文件
	操作文件的函数/方法
		open: 打开文件，返回文件对象,如果文件不存在，会抛出异常
		read：通过文件对象来调用，将文件内容一次性读取到内存并返回
		write： 通过文件对象来调用，将指定内容写入到文件
		close： 通过文件对象来调用，关闭文件
		
		file = open("README")
		text = file.read()
		print(text)
		file.close()  # 开发中，先把打开和关闭写好 再写中间的代码
		
		第一次打开 文件时，通常 文件指针会指向文件的开始位置
		当执行了 read 方法后，文件指针 会移动到 读取内容的末尾
		
打开文件的方式
	open 函数默认以 只读方式 打开文件，并且返回文件对象
	f = open("文件名", "访问方式")
	
	r	以只读方式打开文件。文件的指针将会放在文件的开头，这是默认模式。如果文件不存在，抛出异常
	w	以只写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
	a	以追加方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入
	r+	以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常
	w+	以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件
	a+	以读写方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入
	
	# 频繁的移动文件指针，会影响文件的读写效率，
	# 开发中更多的时候会以 只读、只写 的方式来操作文件，而不会用r+ w+ a+
	
按行读取文件内容
	read 方法默认会把文件的 所有内容 一次性读取到内存
	如果文件太大，对内存的占用会非常严重
	
	readline 方法可以一次读取一行内容
	方法执行后，会把 文件指针 移动到下一行，准备再次读取
	
	使用readLine大文件复制(小文件用read就行)
	
	# 1. 打开文件
	file_read = open("README")
	file_write = open("README[复件]", "w")

	# 2. 读取并写入文件
	while True:
		# 每次读取一行
		text = file_read.readline()

		# 判断是否读取到内容
		if not text:
			break

		file_write.write(text)

	# 3. 关闭文件
	file_read.close()
	file_write.close()
		
在 终端 / 文件浏览器、 中可以执行常规的 文件 / 目录 管理操作，例如：
	创建、重命名、删除、改变路径、查看目录内容、……
	
在 Python 中，如果希望通过程序实现上述功能，需要导入 os 模块（operation system）
	
	01	rename	重命名文件	os.rename(源文件名, 目标文件名)
	02	remove	删除文件	os.remove(文件名)
	01	listdir	目录列表	os.listdir(目录名)
	02	mkdir	创建目录	os.mkdir(目录名)
	03	rmdir	删除目录	os.rmdir(目录名)
	04	getcwd	获取当前目录	os.getcwd()
	05	chdir	修改工作目录	os.chdir(目标目录)
	06	path.isdir	判断是否是文件	os.path.isdir(文件路径)

	Python 2.x 默认使用 ASCII 编码格式
	Python 3.x 默认使用 UTF-8 编码格式
	
	# UTF-8 是 UNICODE 编码的一种编码格式
	
Ptyhon 2.x 中如何使用中文
	在 Python 2.x 文件的 第一行 增加以下代码，解释器会以 utf-8 编码来处理 python 文件
	
	# *-* coding:utf8 *-*
	或者
	# coding=utf8
	
	在 python2.x的文件中，为了避免以字节为单位遍历字符串，
	需要 在字符串的引号前，增加一个小写字母 u，告诉解释器这是一个 unicode 字符串(utf-8)
	
	# *-* coding:utf8 *-*

	# 在字符串前，增加一个 `u` 表示这个字符串是一个 utf8 字符串
	hello_str = u"你好世界"

	print(hello_str)

	for c in hello_str:
		print(c)
		
eval() 函数十分强大 —— 将字符串 当成 有效的表达式 来求值 并 返回计算结果
	# 将字符串两边的引号去掉，并且执行去掉后的表达式
	In [2]: eval("'*' * 10")
	Out[2]: '**********'
	
	In [3]: type(eval("[1, 2, 3, 4, 5]"))
	Out[3]: list

	不滥用eval():在开发时千万不要使用 eval 直接转换 input 的结果

	__import__('os').system('ls')
	等价于：
	import os

	os.system("终端命令")